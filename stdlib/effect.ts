/**
 * Generic interface for declaring effects
 * @typeParam T - The output generated by the effect (defaults to `unknown`)
 *
 * @example
 * ```ts
 * interface MyEffect extends Effect<string[]> {}
 * ```
 */
export interface Effect<T = unknown> {
  /** @hidden */
  output: T
}

/**
 * An implementation of `* -> *` higher-kinded type
 *
 * @typeParam Inp - The input type
 * @typeParam Out - The output type
 *
 * @example
 * You can define a return property for the function body
 *   and use `this['input']` to access the argument
 *   Uses - {@link util.ApplyK}
 *
 * ```ts
 * interface SomeFunc extends Kind1<number, string> {
 *   return: `Your number is ${this['input']}`,
 * }
 *
 * type result = ApplyK<SomeFunc, 200>
 * ```
 */
export interface Kind1<Inp = unknown, Out = unknown> {
  input: Inp
  return: Out
}

/**
 * Generic function definition as a union of a kind and anonymous function
 *
 * @typeParam Inp - The input type
 * @typeParam Out - The output type
 *
 * @example
 * In addition to defining a kind (see - {@link Kind1}),
 *  you can also in some places, use inline lambda functions
 *
 * ```ts
 * type main = Bind<
 *   ReadFile<"./file.txt">,
 *   <contents extends string>() => Print<contents>
 * >
 * ```
 */
export type Func<Inp = unknown, Out = unknown> =
  | Kind1<Inp, Out>
  | (<_T extends Inp>() => Out)

export interface Bind<_Eff extends Effect, _Fn extends Func> extends Effect {}

export interface BindTo<_Name extends string, _Eff extends Effect>
  extends Effect {}
export interface Label<_Name extends string> extends Effect {}

export interface Seq<_Effs extends Effect[]> extends Effect {}

export interface Do<_Effs extends Effect[]> extends Effect {}

export interface Pure<V> extends Effect<V> {}

export interface Noop extends Effect {}
